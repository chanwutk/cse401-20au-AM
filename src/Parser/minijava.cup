/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal CLASS, PUBLIC, STATIC, VOID, MAIN, STRING, EXTENDS, THIS, NEW, IF, ELSE, WHILE, RETURN;

/* built-in types */
terminal BOOLEAN, INT;

/* built-in function */
terminal PRINT, LENGTH;

/* operators */
terminal PLUS, BECOMES;

terminal AND, LESS, MINUS, TIMES, DOT, NOT;

/* delimiters */
terminal LPAREN, RPAREN, SEMICOLON;

terminal LBRACKET, RBRACKET, LBRACKET_SQUARE, RBRACKET_SQUARE, COMMA;

/* boolean values */
terminal TRUE, FALSE;

/* identifiers */
terminal String IDENTIFIER;

/* digits */
terminal Integer DIGIT;

/* Nonterminals (constructed by parser): */

nonterminal Exp Program;
nonterminal Statement Statement;
nonterminal Assign AssignStatement;
nonterminal Print PrintStatement;
nonterminal Exp Expression;
nonterminal Exp AtomicExpression;
nonterminal Identifier Identifier;
nonterminal ExpList ExpressionList;

/* Precedence declarations: */

precedence left AND;
precedence nonassoc LESS;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT;

/* Productions: */

Program ::=
    Expression:e {:
        RESULT = e;
    :};

Statement ::=
    AssignStatement:s {:
        RESULT = s;
    :} |
    PrintStatement:s {:
        RESULT = s;
    :};

AssignStatement ::=
    Identifier:id BECOMES Expression:expr SEMICOLON {:
        RESULT = new Assign(id, expr, idxleft);
    :};

PrintStatement ::=
    PRINT:print LPAREN Expression:expr1 RPAREN SEMICOLON {:
        RESULT = new Print(expr1, printxleft);
    :};

Identifier ::=
    IDENTIFIER:id {:
        RESULT = new Identifier(id, idxleft);
    :};

AtomicExpression ::=
    AtomicExpression:arr LBRACKET_SQUARE Expression:index RBRACKET_SQUARE {:
        RESULT = new ArrayLookup(arr, index, arrxleft);
    :} |
    AtomicExpression:arr DOT LENGTH {:
        RESULT = new ArrayLength(arr, arrxleft);
    :} |
    AtomicExpression:o DOT Identifier:m LPAREN RPAREN:r {:
        RESULT = new Call(o, m, new ExpList(rxleft), oxleft);
    :} |
    AtomicExpression:o DOT Identifier:m LPAREN ExpressionList:args RPAREN {:
        RESULT = new Call(o, m, args, oxleft);
    :} |
    DIGIT:d {:
        RESULT = new IntegerLiteral(d, dxleft);
    :} |
    TRUE:t {:
        RESULT = new True(txleft);
    :} |
    FALSE:f {:
        RESULT = new False(fxleft);
    :} |
    IDENTIFIER:name {:
        RESULT = new IdentifierExp(name, namexleft);
    :} |
    THIS:t {:
        RESULT = new This(txleft);
    :} |
    NEW:n INT LBRACKET_SQUARE Expression:size RBRACKET_SQUARE {:
        RESULT = new NewArray(size, nxleft);
    :} |
    NEW:n Identifier:id LPAREN RPAREN {:
        RESULT = new NewObject(id, nxleft);
    :} |
    LPAREN Expression:expr RPAREN {:
        RESULT = expr;
    :};

Expression ::=
    AtomicExpression:expr {:
        RESULT = expr;
    :} |
    Expression:arg1 AND Expression:arg2 {:
        RESULT = new And(arg1, arg2, arg1xleft);
    :} |
    Expression:arg1 LESS Expression:arg2 {:
        RESULT = new LessThan(arg1, arg2, arg1xleft);
    :} |
    Expression:arg1 PLUS Expression:arg2 {:
        RESULT = new Plus(arg1, arg2, arg1xleft);
    :} |
    Expression:arg1 MINUS Expression:arg2 {:
        RESULT = new Minus(arg1, arg2, arg1xleft);
    :} |
    Expression:arg1 TIMES Expression:arg2 {:
        RESULT = new Times(arg1, arg2, arg1xleft);
    :} |
    NOT:n Expression:expr {:
        RESULT = new Not(expr, nxleft);
    :};

ExpressionList ::=
    Expression:expr {:
        RESULT = new ExpList(exprxleft);
        RESULT.add(expr);
    :} |
    ExpressionList:exprlst COMMA Expression:expr {:
        RESULT = exprlst;
        RESULT.add(expr);
    :};
